\section{Computational Experiments}\label{sec:experiments}
In this section we describe the experiments performed and present the results obtained from them.
First we explain the setup and configurations for the separation routines (\textit{separators} for short) mentioned in \cref{sec:separation}.
Then we present the computational results along with some indications to their expressiveness.

\subsection{Setup}\label{subsec:experiments_setup}
All tests were performed on the same machine running Ubuntu 23.04 as the operating system.
The machine contains an Intel Core i9-12900KF processor running at 4.9 GHz and 64GB of DDR5 RAM. 

The separation routines were implemented in \texttt{C++}.
While some aspects of the code could be improved (\eg computations of shortest paths in parallel like in \cite{sorensenSeparationHeuristic2Partition2020}),
performance was a big concern and we tried to implement the routines as efficiently as possible in the amount of time available for the project.

\href{https://www.gurobi.com}{Gurobi} was used for both, computing the exact solution to the ILP problem and as the LP solver for the cutting plane algorithm.
We chose Gurobi because of its performance compared to other solvers (see \cite{meindlAnalysisCommercialFree2012}) and the capability of solving ILPs and LPs within the same framework.
The code infrastructure is designed flexible enough to use the separation routines either as callbacks to Gurobis ILP solver, or by passing a LP solution directly to them.
Therefore, replacing the LP solver would be fairly easy, \eg for comparing performances of different solvers for this specific problem.
However, this is beyond the scope of the project.

\subsection{Cut Generation}\label{subsec:cut_generation}
The overall procedure of the algorithm is as follows.
We create the LP from the instance data and create some separators according to a provided configuration.
In every iteration we start by solving the current LP relaxation to obtain the solution $x^{*}$.
If $x^{*}$ satsfies all triangle inequalities and is integral, we have found an optimal solution and terminate.
Otherwise we call the separators each after another (starting with the triangle separator) to separate $x^{*}$.
If violated constraints are found, we add them to the LP and start with the next iteration without calling any further separators.
It may thus happen, that a particular separator is never called even it was created according to the configuration,
\eg because an integral solution was found by just calling the separators before it, or because we terminated computation early for some other reason.

\subsection{Cut Deletion}\label{subsec:cut_deletion}
In order to keep the LP at a reasonable size we decided to delete some cutting planes after adding new ones and before optimizing the model again.
Due to implementation details we decided to just remove all non-binding constraints in the current solution.
As \cite{sorensenSeparationHeuristic2Partition2020} pointed out we can only delete cuts if the objective value has strictly worsened.
Otherwise the algorithm might get stuck adding constraints we have previously removed, cycling through the vertices of a hyperplane of the polytope.

\subsection{Limiting Computation}\label{subsec:limiting_computation}
For some instances there is a tendency of the algorithm to add cuts that improve the objective value only marginally for a large number of iterations in a row.
This results in extremely time-consuming computations, for which it was even difficult to give an estimate about how long they might continue.
There is a plethora of possible heuristics to avoid this, but we just decided to terminate the cutting plane procedure after 100\,000 iterations or after an hour of computation time, whichever happens first.

\subsection{Separator Configurations}\label{subsec:run_configs}

\subsection{Results}\label{subsec:experiments_results}

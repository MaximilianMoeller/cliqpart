\section{Computational Experiments}\label{sec:experiments}
This section is concerned with our computational experiments and the results we obtained from them.
First we explain the setup and configurations for the separation routines (\textit{separators} for short) mentioned in \cref{sec:separation}.
Then we present the computational results along with some indications to their expressiveness.

\subsection{Setup}\label{subsec:experiments_setup}
All tests were performed on the same machine running Ubuntu 23.04 as the operating system.
The machine contains an Intel Core i9-12900KF processor running at 4.9 GHz and 64GB of DDR5 RAM. 

The separation routines were implemented in \texttt{C++}.
While some aspects of the code could be improved (\eg computations of shortest paths in parallel like in \cite{sorensenSeparationHeuristic2Partition2020}),
performance was a big concern and we tried to implement the routines as efficiently as possible in the amount of time available for the project.

Gurobi \cite{gurobioptimizationllcGurobiOptimizerReference2023} was used for both, computing the exact solution to the ILP problem and as the LP solver for the cutting plane algorithm.
We chose Gurobi because of its performance compared to other solvers (see \cite{meindlAnalysisCommercialFree2012}) and the capability of solving ILPs and LPs within the same framework.
The code infrastructure is designed flexible enough to use the separation routines either as callbacks to Gurobis ILP solver, or by passing a LP solution directly to them.
Therefore, replacing the LP solver would be fairly easy, \eg for comparing performances of different solvers for this specific problem.
However, this is beyond the scope of the project.

\subsection{Cut Generation}\label{subsec:cut_generation}
The overall procedure of the algorithm is as follows.
We create the LP from the instance data and create some separators according to a provided configuration.
In every iteration we start by solving the current LP relaxation to obtain the solution $x^{*}$.
If $x^{*}$ satsfies all triangle inequalities and is integral, we have found an optimal solution and terminate.
Otherwise we call the separators each after another (starting with the triangle separator) to separate $x^{*}$.
If violated constraints are found, we add them to the LP and start with the next iteration without calling any further separators.
It may thus happen, that a particular separator is never called even if it was created according to the configuration,
\eg because an integral solution was found by just calling the separators before it, or because we terminated computation early for some other reason.

\subsection{Cut Deletion}\label{subsec:cut_deletion}
In order to keep the LP at a reasonable size we decided to delete some cutting planes after adding new ones and before optimizing the model again.
Due to implementation details we decided to just remove all non-binding constraints in the current solution.
As \cite{sorensenSeparationHeuristic2Partition2020} pointed out we can only delete cuts if the objective value has strictly worsened.
Otherwise the algorithm might get stuck adding constraints we have previously removed, cycling through the vertices of a hyperplane of the polytope.

\subsection{Limiting Computation}\label{subsec:limiting_computation}
For some instances there is a tendency of the algorithm to add cuts that improve the objective value only marginally for a large number of iterations in a row.
This results in extremely time-consuming computations, for which it was even difficult to give an estimate about how long they might continue.
There is a plethora of possible heuristics to avoid this, but we just decided to terminate the cutting plane procedure after 10\,000 iterations or after an hour of computation time, whichever happens first.

\subsection{Separator Configuration}\label{subsec:run_configs}
We will now describe configuration parameters for the different separators.
Like for the data instances, every separator will get an abbreviation so we can refer to them easily when discussing results.

Due to numerical reasons we introduce a parameter \texttt{tolerance} for all separators and only regard constraints as violated when their violation degree exceeds this tolerance.
That is, for any constraint $a^{\top} x^{*} \leq \alpha$ we only consider it violated if $a^{\top} x^{*} - \alpha > \texttt{tolerance}$.
We chose $\texttt{tolerance} = \num{e-6}$ for the whole project.
Furthermore, we consider any solution $x^{*}$ integral if the following condition holds for all $e \in E_{n}$:
\[
 \big\lvert x_{e}^{*} - \lfloor x_{e}^{*} + 0.5 \rfloor \big\rvert \leq \texttt{tolerance}
\]

We limit the number of constraints that we would add in every iteration of the cutting plane algorithm by a parameter \texttt{maxcut}.
If we were to set $\texttt{maxcut} = \infty$, \ie not restricting the number of added cutting planes, thousands of violated constraints could be found for even medium sized instances in every iteration.
This would generally result in slower solving of the LP relaxition, which might result in worse overall performance.
On the other hand, setting \texttt{maxcut} too small would result in only small improvements from one iteration to the next.
In order to compare our results with those of \cite{grotschelCuttingPlaneAlgorithm1989} for the instances \texttt{cetacea} and \texttt{cats}, we chose $\texttt{maxcut} = 400$ for all separators.
As we will discuss later, our obtained results suggest that $\texttt{maxcut} = 400$ was in fact not optimal for our problem instances or the modern hardware,
but we did not experiment with this parameter enough to confidently suggest better values.

\subsubsection{Triangle Separator (\texorpdfstring{$\texttt{Δ}_{\texttt{[maxcut]}}^{\texttt{[variable once]}}$}{Δ})}
As discussed earlier, we separate the triangle inequalities by mere enumeration and stop as soon as about $5\cdot\texttt{maxcut}$ violated inequalities are found.
We then sort them by their violation degree and only add the \texttt{maxcut} most violated ones to the LP.

The triangle separator is the only one for which we tried setting $\texttt{maxcut} = \infty$ and we will indicate that this setting was used by writing $\texttt{Δ}_{\infty}$.

The enumeration of triangle inequalities is always carried out in the same order.
We imagined that this could lead to a scenario where the ‘earlier’ regions of the graph would already be ‘partially’ solved, whereas in the ‘later’ regions of the enumeration order there would still be violated constraints with high violation degree.
To circumvent this, we introduce another parameter called \texttt{variable once} which, when activated would affect the separator as follows:
For every variable we add at most one triangle inequality containing this variable.
We hoped that this would result in the graph being solved more ‘evenly’.
The use of the \texttt{variable once} parameter will be indicated by $\texttt{Δ}^{\leq 1}$.
We imagined that it would be most useful in combination with $\texttt{maxcut} = \infty$, because otherwise we would still only enumerate the $5 \cdot \texttt{maxcut}$ first violated inequalities, which might not cover ‘later’ regions of the graph.

\subsubsection{2-Partition Separator (\texorpdfstring{$\texttt{st}^{\texttt{[heuristic]}}$}{Δ})}
We use the two heuristics described in \cite{grotschelCuttingPlaneAlgorithm1989} to search for violated $\left[ S,T \right]$-inequalities with $\lvert S \rvert = 1$ and we do not want to repeat their explanation here.
They will be notated by $\texttt{Δ}^{1}$ and $\texttt{Δ}^{2}$.
As before, we add no more than \texttt{maxcut} violated inequalities to the LP, and because we did not experiment with this parameter for all further separators, we will not denote it in the abbreviations.

\subsubsection{Two-Chorded (\texttt{two}) and Half-Chorded (\texttt{half}) Odd Cycle Separator}
The separator for the two- and half-chorded odd cycle inequalities works mostly as described in \cref{subsec:two_chorded_separator}.
However, we limit computation time to 15 minutes, because not imposing any time limit would sometimes result in the routine taking more than an hour to finish.
Especially so for separation of the two-chorded odd cycyle inequalities due to the higher exponent in the time complexity of the routine (cf.\ \cref{subsec:two_chorded_separator} and \cref{subsec:half_chorded_separator}).
We remark that the \texttt{maxcut} limit was often hit before the time limit.

\subsection{Separator Combinations}\label{subsec:separator_combinations}
We are interested in the practical use of different combinations of these separators with possibly different configurations.
In our experience, the separators for two- and half-chorded odd cycle inequalities needed considerably more time to find violated constraints than the others, which is due to the higher exponent in run time complexity.
To evaluate whether the improvement in the tightness of the relaxation is worth the additional computation time required, we created multiple combinations of differently parametrized separators that we call \textit{run configurations}.
The following table shows the names we chose to give to these run configurations and the separators they include in order:
\begin{table}[H]
	\centering
	\begin{tabular}{|l||c|c|c|c|c|c|c||}
		\hline
			& \texttt{all} 	& \texttt{cycles} & \texttt{two} & \texttt{half}	& \texttt{st-1} & \texttt{st-2} & \texttt{st-12} \\[0.5ex]
		\hline\hline
		1 	& \texttt{Δ} 	& \texttt{Δ} 				& \texttt{Δ} 	& \texttt{Δ} 		& \texttt{Δ} 	& \texttt{Δ} 	& \texttt{Δ} 	\\ 
		2 	& $\texttt{st}^{1}$ & \texttt{half} & \texttt{two} 			& \texttt{half} 				& $\texttt{st}^{1}$ 			& $\texttt{st}^{2}$  		& $\texttt{st}^{1}$			\\
		3 	& $\texttt{st}^{2}$			& \texttt{two} 						&--- &--- &---  			&--- & $\texttt{st}^{2}$			\\
		4 	& \texttt{half} &--- &---&---&---&---&---  \\
		5 	& \texttt{two}	&--- &---&---&---&---&---	\\
		\hline
	\end{tabular}
	\caption{Combining separators into run configurations.}
\end{table}
Furthermore, \texttt{Δ}, $\texttt{Δ}_{\infty}$, $\texttt{Δ}^{\leq 1}$ and $\texttt{Δ}_{\infty}^{\leq 1}$ can be viewed as full run configurations on their own.

\subsection{Results}\label{subsec:experiments_results}
\subsubsection{A Note on Computation Time}
We want to address some flaws in the setup of our experiments.
Unfortunately, we noticed them to late into the project and could not correct them in the time available.
Firstly, while logging important variables (\eg, the number of cuts added and removed) every iteration, we made the mistake to also log every solution to the LP relaxations.
For the non-random instances alone, this amounts to approximately 90 GB of text files.
The issue here is that writing a solution file to disk takes some amount of time that we can hardly factor out of our results.
Secondly, we did not log the times it took to solve the LP relaxation and then searching for violated constraints independently.
Rather we only recorded progress once after every call to a separator and used the fact that the logging library timestamps every logged message to deduce running times.
The time to solve the LP was thus always reported together with the first separator, which is always the triangle separator.
Especially run configurations that only include triangle separators, \eg \texttt{Δ} and $\texttt{Δ}_{\infty}$, are therefore impossible to compare precisely.
We would not know whether an increase in iteration time when using $\texttt{Δ}_{\infty}$ would be caused by the LP solver taking longer due to bigger LP size, or by the separator searching for all violated inequalities instead of terminating after \texttt{maxcut} have been found.
Every further log in this iteration did then not include time spent on solving the LP, but rather just the time spent in our separation routines, because the LP solver had not been started again.
This means that for iterations where the triangle separator failed to produce a violated inequality, we do know how much time was spent in all other separation routines separately. 

Admittedly, exact running time was of less concern to us than the qualitative differences in LP relaxations obtained from the use of various combinations of inequality classes.
The simple logging techniques we used gave us a good grasp on the overall progress made per iteration.
However, we do not believe that they were sophisticated enough to even report accurately on the time frames of interest here.
Especially in (but not limited to) the first few iterations, many violated constraints can be found quickly, leading to durations in the order of milliseconds for a whole iteration, \ie solving the LP and separating the obtained solution.
Nevertheless, we regret these flaws and suggest to interpret the obtained results with some caveats.

We will therefore refrain from breaking down execution times further and rather just state the total time spent on one run.
\todo{ja?}
